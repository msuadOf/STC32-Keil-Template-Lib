C251 COMPILER V5.60.0,  STC32G_CAN                                                         14/05/23  10:09:41  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE STC32G_CAN
OBJECT MODULE PLACED IN .\MDK\Obj\STC32G_CAN.obj
COMPILER INVOKED BY: D:\Program\Keil_v5\C251\BIN\C251.EXE Driver\Src\STC32G_CAN.c XSMALL INTR2 OPTIMIZE(0,SPEED) BROWSE 
                    -INCDIR(.\Driver;.\Driver\Inc;.\Driver\Isr;.\CORE\Inc;.\bsp\include) DEBUG PRINT(.\MDK\List\STC32G_CAN.lst) TABS(2) OBJEC
                    -T(.\MDK\Obj\STC32G_CAN.obj) 

stmt  level    source

    1          /*---------------------------------------------------------------------*/
    2          /* --- STC MCU Limited ------------------------------------------------*/
    3          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
    4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
    5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
    6          /* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
    7          /* --- Web: www.STCAI.com ---------------------------------------------*/
    8          /* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
    9          /* --- BBS: www.STCAIMCU.com  -----------------------------------------*/
   10          /* --- QQ:  800003751 -------------------------------------------------*/
   11          /* Èç¹ûÒªÔÚ³ÌÐòÖÐÊ¹ÓÃ´Ë´úÂë,ÇëÔÚ³ÌÐòÖÐ×¢Ã÷Ê¹ÓÃÁËSTCµÄ×ÊÁÏ¼°³ÌÐò            */
   12          /*---------------------------------------------------------------------*/
   13          
   14          #include "STC32G_CAN.h"
   15          
   16          CAN_DataDef CAN1_Tx;
   17          CAN_DataDef CAN1_Rx[8];
   18          
   19          CAN_DataDef CAN2_Tx;
   20          CAN_DataDef CAN2_Rx[8];
   21          
   22          //========================================================================
   23          // º¯Êý: u8 ReadReg(u8 addr)
   24          // ÃèÊö: CAN¹¦ÄÜ¼Ä´æÆ÷¶ÁÈ¡º¯Êý¡£
   25          // ²ÎÊý: CAN¹¦ÄÜ¼Ä´æÆ÷µØÖ·.
   26          // ·µ»Ø: CAN¹¦ÄÜ¼Ä´æÆ÷Êý¾Ý.
   27          // °æ±¾: VER1.0
   28          // ÈÕÆÚ: 2020-11-16
   29          // ±¸×¢: 
   30          //========================================================================
   31          u8 CanReadReg(u8 addr)
   32          {
   33   1          u8 dat;
   34   1          CANAR = addr;
   35   1          dat = CANDR;
   36   1          return dat;
   37   1      }
   38          
   39          //========================================================================
   40          // º¯Êý: void WriteReg(u8 addr, u8 dat)
   41          // ÃèÊö: CAN¹¦ÄÜ¼Ä´æÆ÷ÅäÖÃº¯Êý¡£
   42          // ²ÎÊý: CAN¹¦ÄÜ¼Ä´æÆ÷µØÖ·, CAN¹¦ÄÜ¼Ä´æÆ÷Êý¾Ý.
   43          // ·µ»Ø: none.
   44          // °æ±¾: VER1.0
   45          // ÈÕÆÚ: 2020-11-16
   46          // ±¸×¢: 
   47          //========================================================================
   48          void CanWriteReg(u8 addr, u8 dat)
   49          {
   50   1          CANAR = addr;
   51   1          CANDR = dat;
   52   1      }
   53          
   54          //========================================================================
   55          // º¯Êý: void CAN_Inilize(u8 CANx, CAN_InitTypeDef *CAN)
   56          // ÃèÊö: CAN ³õÊ¼»¯³ÌÐò.
   57          // ²ÎÊý: CAN: ½á¹¹²ÎÊý,Çë²Î¿¼CAN.hÀïµÄ¶¨Òå.
C251 COMPILER V5.60.0,  STC32G_CAN                                                         14/05/23  10:09:41  PAGE 2   

   58          // ·µ»Ø: none.
   59          // °æ±¾: V1.0, 2021-06-02
   60          //========================================================================
   61          void CAN_Inilize(u8 CANx, CAN_InitTypeDef *CAN)
   62          {
   63   1          if(CANx == CAN1)
   64   1          {
   65   2              CANSEL = CAN1;    //Ñ¡ÔñCAN1Ä£¿é
   66   2              CanWriteReg(MR  ,0x04);   //Ê¹ÄÜ Reset Mode
   67   2      
   68   2              if(CAN->CAN_Enable == ENABLE) CANEN = 1;    //Ê¹ÄÜCAN1Ä£¿é
   69   2              else                CANEN = 0;    //¹Ø±ÕCAN1Ä£¿é
   70   2              
   71   2              CanWriteReg(BTR0,(u8)((CAN->CAN_SJW << 6) + CAN->CAN_BRP));
   72   2              CanWriteReg(BTR1,(u8)((CAN->CAN_SAM << 7) + (CAN->CAN_TSG2 << 4) + CAN->CAN_TSG1));
   73   2      
   74   2              CanWriteReg(ACR0,CAN->CAN_ACR0);    //×ÜÏßÑéÊÕ´úÂë¼Ä´æÆ÷
   75   2              CanWriteReg(ACR1,CAN->CAN_ACR1);
   76   2              CanWriteReg(ACR2,CAN->CAN_ACR2);
   77   2              CanWriteReg(ACR3,CAN->CAN_ACR3);
   78   2              CanWriteReg(AMR0,CAN->CAN_AMR0);    //×ÜÏßÑéÊÕÆÁ±Î¼Ä´æÆ÷
   79   2              CanWriteReg(AMR1,CAN->CAN_AMR1);
   80   2              CanWriteReg(AMR2,CAN->CAN_AMR2);
   81   2              CanWriteReg(AMR3,CAN->CAN_AMR3);
   82   2      
   83   2              CanWriteReg(ISR ,0xff);   //ÇåÖÐ¶Ï±êÖ¾
   84   2              CanWriteReg(IMR ,CAN->CAN_IMR);     //ÖÐ¶Ï¼Ä´æÆ÷ÉèÖÃ
   85   2              CanWriteReg(MR  ,0x00);   //ÍË³ö Reset Mode
   86   2          }
   87   1          else if(CANx == CAN2)
   88   1          {
   89   2              CANSEL = CAN2;    //Ñ¡ÔñCAN2Ä£¿é
   90   2              
   91   2              CanWriteReg(MR  ,0x04);   //Ê¹ÄÜ Reset Mode
   92   2      
   93   2              if(CAN->CAN_Enable == ENABLE) CAN2EN = 1;   //Ê¹ÄÜCAN2Ä£¿é
   94   2              else                CAN2EN = 0;   //¹Ø±ÕCAN2Ä£¿é
   95   2              
   96   2              CanWriteReg(BTR0,(u8)((CAN->CAN_SJW << 6) + CAN->CAN_BRP));
   97   2              CanWriteReg(BTR1,(u8)((CAN->CAN_SAM << 7) + (CAN->CAN_TSG2 << 4) + CAN->CAN_TSG1));
   98   2      
   99   2              CanWriteReg(ACR0,CAN->CAN_ACR0);    //×ÜÏßÑéÊÕ´úÂë¼Ä´æÆ÷
  100   2              CanWriteReg(ACR1,CAN->CAN_ACR1);
  101   2              CanWriteReg(ACR2,CAN->CAN_ACR2);
  102   2              CanWriteReg(ACR3,CAN->CAN_ACR3);
  103   2              CanWriteReg(AMR0,CAN->CAN_AMR0);    //×ÜÏßÑéÊÕÆÁ±Î¼Ä´æÆ÷
  104   2              CanWriteReg(AMR1,CAN->CAN_AMR1);
  105   2              CanWriteReg(AMR2,CAN->CAN_AMR2);
  106   2              CanWriteReg(AMR3,CAN->CAN_AMR3);
  107   2      
  108   2              CanWriteReg(ISR ,0xff);   //ÇåÖÐ¶Ï±êÖ¾
  109   2              CanWriteReg(IMR ,CAN->CAN_IMR);     //ÖÐ¶Ï¼Ä´æÆ÷ÉèÖÃ
  110   2              CanWriteReg(MR  ,0x00);   //ÍË³ö Reset Mode
  111   2          }
  112   1      }
  113          
  114          //========================================================================
  115          // º¯Êý: void CanReadFifo(CAN_DataDef *CANx)
  116          // ÃèÊö: ¶ÁÈ¡CAN»º³åÇøÊý¾Ýº¯Êý¡£
  117          // ²ÎÊý: *CANx: ´æ·ÅCAN×ÜÏß¶ÁÈ¡Êý¾Ý.
  118          // ·µ»Ø: none.
  119          // °æ±¾: VER2.0
  120          // ÈÕÆÚ: 2023-01-31
  121          // ±¸×¢: 
  122          //========================================================================
  123          void CanReadFifo(CAN_DataDef *CAN)
C251 COMPILER V5.60.0,  STC32G_CAN                                                         14/05/23  10:09:41  PAGE 3   

  124          {
  125   1          u8 i;
  126   1          u8 pdat[5];
  127   1          u8 RX_Index=0;
  128   1      
  129   1          pdat[0] = CanReadReg((u8)(RX_BUF0 + (RX_Index++&3)));
  130   1      
  131   1          if(pdat[0] & 0x80)  //ÅÐ¶ÏÊÇ±ê×¼Ö¡»¹ÊÇÀ©Õ¹Ö¡
  132   1          {
  133   2              pdat[1] = CanReadReg((u8)(RX_BUF0 + (RX_Index++&3)));   //À©Õ¹Ö¡IDÕ¼4¸ö×Ö½Ú
  134   2              pdat[2] = CanReadReg((u8)(RX_BUF0 + (RX_Index++&3)));
  135   2              pdat[3] = CanReadReg((u8)(RX_BUF0 + (RX_Index++&3)));
  136   2              pdat[4] = CanReadReg((u8)(RX_BUF0 + (RX_Index++&3)));
  137   2              CAN->ID = (((u32)pdat[1] << 24) + ((u32)pdat[2] << 16) + ((u32)pdat[3] << 8) + pdat[4]) >> 3;
  138   2          }
  139   1          else
  140   1          {
  141   2              pdat[1] = CanReadReg((u8)(RX_BUF0 + (RX_Index++&3)));   //±ê×¼Ö¡IDÕ¼2¸ö×Ö½Ú
  142   2              pdat[2] = CanReadReg((u8)(RX_BUF0 + (RX_Index++&3)));
  143   2              CAN->ID = ((pdat[1] << 8) + pdat[2]) >> 5;
  144   2          }
  145   1          
  146   1          CAN->FF = pdat[0] >> 7;     //Ö¡¸ñÊ½
  147   1          CAN->RTR = pdat[0] >> 6;    //Ö¡ÀàÐÍ
  148   1          CAN->DLC = pdat[0];         //Êý¾Ý³¤¶È
  149   1      
  150   1          for(i=0;((i<CAN->DLC) && (i<8));i++)        //¶ÁÈ¡Êý¾Ý³¤¶ÈÎªlen£¬×î¶à²»³¬¹ý8
  151   1          {
  152   2              CAN->DataBuffer[i] = CanReadReg((u8)(RX_BUF0 + (RX_Index++&3)));   //¶ÁÈ¡ÓÐÐ§Êý¾Ý
  153   2          }
  154   1          while(RX_Index&3)   //ÅÐ¶ÏÒÑ¶ÁÊý¾Ý³¤¶ÈÊÇ·ñ4µÄÕûÊý±¶
  155   1          {
  156   2              CanReadReg((u8)(RX_BUF0 + (RX_Index++&3)));  //¶ÁÈ¡Ìî³äÊý¾Ý£¬Ò»Ö¡Êý¾ÝÕ¼¾Ý4µÄÕûÊý±¶»º³åÇø¿Õ¼ä£¬²»×
             -ã²¹0
  157   2          }
  158   1      }
  159          
  160          //========================================================================
  161          // º¯Êý: u8 CanReadMsg(void)
  162          // ÃèÊö: CAN½ÓÊÕÊý¾Ýº¯Êý¡£
  163          // ²ÎÊý: *CANx: ´æ·ÅCAN×ÜÏß¶ÁÈ¡Êý¾Ý..
  164          // ·µ»Ø: Ö¡¸öÊý.
  165          // °æ±¾: VER2.0
  166          // ÈÕÆÚ: 2023-01-31
  167          // ±¸×¢: 
  168          //========================================================================
  169          u8 CanReadMsg(CAN_DataDef *CAN)
  170          {
  171   1          u8 i;
  172   1          u8 n=0;
  173   1      
  174   1          do{
  175   2              CanReadFifo(&CAN[n++]);  //¶ÁÈ¡½ÓÊÕ»º³åÇøÊý¾Ý
  176   2              i = CanReadReg(SR);
  177   2          }while(i&0x80);     //ÅÐ¶Ï½ÓÊÕ»º³åÇøÀïÊÇ·ñ»¹ÓÐÊý¾Ý£¬ÓÐµÄ»°¼ÌÐø¶ÁÈ¡
  178   1      
  179   1          return n;   //·µ»ØÖ¡¸öÊý
  180   1      }
  181          
  182          //========================================================================
  183          // º¯Êý: void CanSendMsg(CAN_DataDef *CAN)
  184          // ÃèÊö: CAN·¢ËÍ±ê×¼Ö¡º¯Êý¡£
  185          // ²ÎÊý: *CANx: ´æ·ÅCAN×ÜÏß·¢ËÍÊý¾Ý..
  186          // ·µ»Ø: none.
  187          // °æ±¾: VER1.0
  188          // ÈÕÆÚ: 2020-11-19
C251 COMPILER V5.60.0,  STC32G_CAN                                                         14/05/23  10:09:41  PAGE 4   

  189          // ±¸×¢: 
  190          //========================================================================
  191          void CanSendMsg(CAN_DataDef *CAN)
  192          {
  193   1        u32 CanID;
  194   1          u8 RX_Index,i;
  195   1      
  196   1          if(CAN->FF)     //ÅÐ¶ÏÊÇ·ñÀ©Õ¹Ö¡
  197   1          {
  198   2              CanID = CAN->ID << 3;
  199   2              CanWriteReg(TX_BUF0,CAN->DLC|((u8)CAN->RTR<<6)|0x80); //bit7: ±ê×¼Ö¡(0)/À©Õ¹Ö¡(1), bit6: Êý¾ÝÖ¡(0
             -)/Ô¶³ÌÖ¡(1), bit3~bit0: Êý¾Ý³¤¶È(DLC)
  200   2              CanWriteReg(TX_BUF1,(u8)(CanID>>24));
  201   2              CanWriteReg(TX_BUF2,(u8)(CanID>>16));
  202   2              CanWriteReg(TX_BUF3,(u8)(CanID>>8));
  203   2      
  204   2              CanWriteReg(TX_BUF0,(u8)CanID);
  205   2      
  206   2              RX_Index = 1;
  207   2              for(i=0;((i<CAN->DLC) && (i<8));i++)        //Êý¾Ý³¤¶ÈÎªDLC£¬×î¶à²»³¬¹ý8
  208   2              {
  209   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++&3)),CAN->DataBuffer[i]);   //Ð´ÈëÓÐÐ§Êý¾Ý
  210   3              }
  211   2              while(RX_Index&3)   //ÅÐ¶ÏÒÑ¶ÁÊý¾Ý³¤¶ÈÊÇ·ñ4µÄÕûÊý±¶
  212   2              {
  213   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++&3)),0x00);  //Ð´ÈëÌî³äÊý¾Ý£¬Ò»Ö¡Êý¾ÝÕ¼¾Ý4µÄÕûÊý±¶»º³åÇ
             -ø¿Õ¼ä£¬²»×ã²¹0
  214   3              }
  215   2          }
  216   1          else    //·¢ËÍ±ê×¼Ö¡
  217   1          {
  218   2              CanID = (u16)(CAN->ID << 5);
  219   2              CanWriteReg(TX_BUF0,CAN->DLC|((u8)CAN->RTR<<6));  //bit7: ±ê×¼Ö¡(0)/À©Õ¹Ö¡(1), bit6: Êý¾ÝÖ¡(0)/Ô¶
             -³ÌÖ¡(1), bit3~bit0: Êý¾Ý³¤¶È(DLC)
  220   2              CanWriteReg(TX_BUF1,(u8)(CanID>>8));
  221   2              CanWriteReg(TX_BUF2,(u8)CanID);
  222   2      
  223   2              RX_Index = 3;
  224   2              for(i=0;((i<CAN->DLC) && (i<8));i++)        //Êý¾Ý³¤¶ÈÎªDLC£¬×î¶à²»³¬¹ý8
  225   2              {
  226   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++&3)),CAN->DataBuffer[i]);   //Ð´ÈëÓÐÐ§Êý¾Ý
  227   3              }
  228   2              while(RX_Index&3)   //ÅÐ¶ÏÒÑ¶ÁÊý¾Ý³¤¶ÈÊÇ·ñ4µÄÕûÊý±¶
  229   2              {
  230   3                  CanWriteReg((u8)(TX_BUF0 + (RX_Index++&3)),0x00);  //Ð´ÈëÌî³äÊý¾Ý£¬Ò»Ö¡Êý¾ÝÕ¼¾Ý4µÄÕûÊý±¶»º³åÇ
             -ø¿Õ¼ä£¬²»×ã²¹0
  231   3              }
  232   2          }
  233   1        CanWriteReg(CMR ,0x04);   //·¢ÆðÒ»´ÎÖ¡´«Êä
  234   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1829     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       270     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
C251 COMPILER V5.60.0,  STC32G_CAN                                                         14/05/23  10:09:41  PAGE 5   

  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
